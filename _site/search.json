[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Statistical Computing - HLLMAX005 - Project 2 Hand-in",
    "section": "",
    "text": "Link to GitHub Repository: HLLMAX005’s GitHub Repository"
  },
  {
    "objectID": "index.html#github-repository",
    "href": "index.html#github-repository",
    "title": "Statistical Computing - HLLMAX005 - Project 2 Hand-in",
    "section": "",
    "text": "Link to GitHub Repository: HLLMAX005’s GitHub Repository"
  },
  {
    "objectID": "Parallelisation_Prac.html",
    "href": "Parallelisation_Prac.html",
    "title": "Parallelisation Practical",
    "section": "",
    "text": "Use a foreach loop to repeat 100 times:\n\nGenerate a random sample from an exponential distribution with mean 1\nCalculate mean and variance\nRow-bind your results (rbind) (results = mean and variance).\n\n\nN &lt;- 100\nn &lt;- 100\n\ngenerated_samples &lt;- foreach(1:N, .combine = rbind) %do% \n  {\n    sample &lt;- rexp(n, rate = 1)\n    c(mean(sample), var(sample))\n  }\n\n# Checking expected output (Mean and Variance approx. 1)\ncolMeans(generated_samples)\n\n[1] 1.0024249 0.9864263"
  },
  {
    "objectID": "Parallelisation_Prac.html#question-1",
    "href": "Parallelisation_Prac.html#question-1",
    "title": "Parallelisation Practical",
    "section": "",
    "text": "Use a foreach loop to repeat 100 times:\n\nGenerate a random sample from an exponential distribution with mean 1\nCalculate mean and variance\nRow-bind your results (rbind) (results = mean and variance).\n\n\nN &lt;- 100\nn &lt;- 100\n\ngenerated_samples &lt;- foreach(1:N, .combine = rbind) %do% \n  {\n    sample &lt;- rexp(n, rate = 1)\n    c(mean(sample), var(sample))\n  }\n\n# Checking expected output (Mean and Variance approx. 1)\ncolMeans(generated_samples)\n\n[1] 1.0024249 0.9864263"
  },
  {
    "objectID": "Parallelisation_Prac.html#question-2",
    "href": "Parallelisation_Prac.html#question-2",
    "title": "Parallelisation Practical",
    "section": "Question 2",
    "text": "Question 2\nUse the doParallel package and foreach to bootstrap the median for the galaxies data (in library MASS).\nIf the foreach function needs access to data or a function from a certain package, this can be done by adding the .packages='MASS' (for example) argument.\nHow does processing time compare to that of serial processing? If each iteration’s run time is small, relative to the amount of data that needs to be loaded and returned, parallel processing might not actually speed up the total run time. Bootstrapping is relatively small: draw a sample, calculate a statistic. It might only start making a difference if each chunk becomes large relatively to the overheads of data transfer. Experiment with this. Try doing 1000 bootstrap samples at a time instead of managing single bootstrap samples.\n\ntotal_num_boot &lt;- 10000\nB              &lt;- total_num_boot    # Number of bootstrap Samples\nn              &lt;- length(galaxies)  # Number of samples per\n\ncl &lt;- makeCluster(7)\nregisterDoParallel(cl)\n\n# For small task (1 sample) - 1 thread\nsystem.time(\n{\n  median_boot &lt;- foreach(i = 1:B, .packages = \"MASS\", .combine = rbind) %do% \n  {\n    Sys.sleep(0.001)\n    median(sample(galaxies, n, replace = TRUE))\n  }\n})\n\n   user  system elapsed \n  4.483   0.138  17.302 \n\n# For a small task (1 sample per thread)\nsystem.time(\n{\n  median_boot &lt;- foreach(i = 1:B, .packages = \"MASS\", .combine = rbind) %dopar% \n  {\n    Sys.sleep(0.001)\n    median(sample(galaxies, n, replace = TRUE))\n  }\n})\n\n   user  system elapsed \n  1.168   0.197   2.771 \n\n# For a small task (1000 sample per thread)\nnum_per_boot   &lt;- 1000\nB_multi &lt;- total_num_boot/num_per_boot\n\nsystem.time(\n{\n  median_boot &lt;- foreach(i = 1:B_multi, .packages = \"MASS\", .combine = rbind) %dopar% \n  {\n    Sys.sleep(0.001)\n    replicate(num_per_boot, median(sample(galaxies, n, replace = TRUE)))\n  }\n})\n\n   user  system elapsed \n  0.003   0.001   0.056 \n\nstopCluster(cl)"
  },
  {
    "objectID": "Parallelisation_Prac.html#question-3",
    "href": "Parallelisation_Prac.html#question-3",
    "title": "Parallelisation Practical",
    "section": "Question 3",
    "text": "Question 3\nEstimate coverage of a percentile bootstrap confidence interval for the following scenario: sample of size 50 from an exponential distribution with mean 1.\n\nboot_exp_ci &lt;- function(samples, alpha)\n{\n  # Bootstrapping Means and Finding Quantile CI\n  sample_mean  &lt;- replicate(1000, mean(sample(samples, replace = TRUE)))\n  cis &lt;- quantile(sample_mean, c(alpha, 1 - alpha))\n  \n  return(cis)\n}\n\n# Initialising\nn    &lt;- 50\nrate &lt;- 1\nB    &lt;- 1000\ncl   &lt;- makeCluster(7)\nregisterDoParallel(cl)\n\n# Generating B Bootstrap Percentile CI's\ngenerated_cis &lt;- foreach(1:B, .combine = rbind) %dopar%\n{\n  samples &lt;- rexp(n, rate)\n  boot_exp_ci(samples, 0.025)\n}\n\nstopCluster(cl)\n\n# Calculating the coverage of the CI\nprop_cov &lt;- sum(1/rate &gt;= generated_cis[,1] & 1/rate &lt;= generated_cis[,2]) / B\nprop_cov\n\n[1] 0.924"
  },
  {
    "objectID": "Parallelisation_Prac.html#question-4",
    "href": "Parallelisation_Prac.html#question-4",
    "title": "Parallelisation Practical",
    "section": "Question 4",
    "text": "Question 4\nThe package iterators provides several functions that can be used to create sequences for the foreach function. For example, the irnorm function creates an object that iterates over vectors of normally distributed random numbers. It is useful when you need to use random variables drawn from one distribution in an expression that is run in parallel.\nIn this exercise, use the foreach and irnorm functions to iterate over 3 vectors, each containing 5 random variables. Find the largest value in each vector, and print those largest values.\nBefore running the foreach function set the seed to 1234.\n\nset.seed(1234)\nnorms &lt;- irnorm(n = 5, mean = 0, sd = 1)\n\nforeach(i = 1:3, .combine = rbind, .packages = 'iterators') %do%\n{\n  max(nextElem(norms))\n}\n\n              [,1]\nresult.1 1.0844412\nresult.2 0.5060559\nresult.3 0.9594941"
  },
  {
    "objectID": "Parallelisation_Prac.html#question-5",
    "href": "Parallelisation_Prac.html#question-5",
    "title": "Parallelisation Practical",
    "section": "Question 5",
    "text": "Question 5\n\n# Function which applies the nextElem function to an iterator \n# and returns its max\ntask_func &lt;- function(iter)\n{\n  return(max(iterators::nextElem(iter)))\n}\n\n# For parLapply Function\ncl &lt;- makeCluster(getOption(\"cl.cores\", 4))\n\n# parLapply doesn't work with libraries\ntryCatch({\n  system.time(\n  {\n    set.seed(1234)\n    iter &lt;- irnorm(n = 5, mean = 0, sd = 1)\n    parLapply(cl, iter, task_func)\n  })\n}, error = function(e) {\n  # Code doesn't run as parLapply doesn't allow for external libraries\n  print(\"Code doesn't run as parLapply doesn't allow for external libraries\")\n})\n\nTiming stopped at: 0 0 0.002\n\n\n[1] \"Code doesn't run as parLapply doesn't allow for external libraries\"\n\nstopCluster(cl)\n\n\n#  For foreach Function\ncl &lt;- makeCluster(4)\nregisterDoParallel(cl)\n\nsystem.time(\n{\n  set.seed(1234)\n  norms &lt;- irnorm(n = 5, mean = 0, sd = 1)\n  \n  foreach(i = 1:3, .combine = rbind, .packages = 'iterators') %dopar%\n  {\n    task_func(norms)\n  }\n})\n\n   user  system elapsed \n  0.001   0.000   0.009 \n\nstopCluster(cl)\n\n\n# For replicate Function: faster as is a simple task (no overheads)\nsystem.time(\n{\n  set.seed(1234)\n  norms &lt;- irnorm(n = 5, mean = 0, sd = 1)\n  output &lt;- replicate(3, task_func(norms))\n})\n\n   user  system elapsed \n  0.001   0.000   0.001"
  }
]